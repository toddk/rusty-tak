// This file is @generated by prost-build.
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Contact {
    /// Endpoint is optional; if missing/empty do not populate.
    ///
    /// endpoint=
    #[prost(string, tag = "1")]
    pub endpoint: ::prost::alloc::string::String,
    /// callsign=
    #[prost(string, tag = "2")]
    pub callsign: ::prost::alloc::string::String,
}
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Group {
    /// name=
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// role=
    #[prost(string, tag = "2")]
    pub role: ::prost::alloc::string::String,
}
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrecisionLocation {
    /// geopointsrc=
    #[prost(string, tag = "1")]
    pub geopointsrc: ::prost::alloc::string::String,
    /// altsrc=
    #[prost(string, tag = "2")]
    pub altsrc: ::prost::alloc::string::String,
}
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Status {
    /// battery=
    #[prost(uint32, tag = "1")]
    pub battery: u32,
}
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Takv {
    /// device=
    #[prost(string, tag = "1")]
    pub device: ::prost::alloc::string::String,
    /// platform=
    #[prost(string, tag = "2")]
    pub platform: ::prost::alloc::string::String,
    /// os=
    #[prost(string, tag = "3")]
    pub os: ::prost::alloc::string::String,
    /// version=
    #[prost(string, tag = "4")]
    pub version: ::prost::alloc::string::String,
}
/// All items are required unless otherwise noted!
/// "required" means if they are missing on send, the conversion
/// to the message format will be rejected and fall back to opaque
/// XML representation
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Track {
    /// speed=
    #[prost(double, tag = "1")]
    pub speed: f64,
    /// course=
    #[prost(double, tag = "2")]
    pub course: f64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Detail {
    #[prost(string, tag = "1")]
    pub xml_detail: ::prost::alloc::string::String,
    /// <contact>
    #[prost(message, optional, tag = "2")]
    pub contact: ::core::option::Option<Contact>,
    /// <__group>
    #[prost(message, optional, tag = "3")]
    pub group: ::core::option::Option<Group>,
    /// <precisionlocation>
    #[prost(message, optional, tag = "4")]
    pub precision_location: ::core::option::Option<PrecisionLocation>,
    /// <status>
    #[prost(message, optional, tag = "5")]
    pub status: ::core::option::Option<Status>,
    /// <takv>
    #[prost(message, optional, tag = "6")]
    pub takv: ::core::option::Option<Takv>,
    /// <track>
    #[prost(message, optional, tag = "7")]
    pub track: ::core::option::Option<Track>,
}
/// A note about timestamps:
/// Uses "timeMs" units, which is number of milliseconds since
/// 1970-01-01 00:00:00 UTC
///
/// All items are required unless otherwise noted!
/// "required" means if they are missing in the XML during outbound
/// conversion to protobuf, the message will be
/// rejected
///
/// <event>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CotEvent {
    /// <event type="x">
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// optional
    #[prost(string, tag = "2")]
    pub access: ::prost::alloc::string::String,
    /// optional
    #[prost(string, tag = "3")]
    pub qos: ::prost::alloc::string::String,
    /// optional
    #[prost(string, tag = "4")]
    pub opex: ::prost::alloc::string::String,
    /// <event uid="x">
    #[prost(string, tag = "5")]
    pub uid: ::prost::alloc::string::String,
    /// <event time="x"> converted to timeMs
    #[prost(uint64, tag = "6")]
    pub send_time: u64,
    /// <event start="x"> converted to timeMs
    #[prost(uint64, tag = "7")]
    pub start_time: u64,
    /// <event stale="x"> converted to timeMs
    #[prost(uint64, tag = "8")]
    pub stale_time: u64,
    /// <event how="x">
    #[prost(string, tag = "9")]
    pub how: ::prost::alloc::string::String,
    /// <point>
    ///
    /// <point lat="x">
    #[prost(double, tag = "10")]
    pub lat: f64,
    /// <point lon="x">
    #[prost(double, tag = "11")]
    pub lon: f64,
    /// <point hae="x"> use 999999 for unknown
    #[prost(double, tag = "12")]
    pub hae: f64,
    /// <point ce="x"> use 999999 for unknown
    #[prost(double, tag = "13")]
    pub ce: f64,
    /// <point ce="x"> use 999999 for unknown
    #[prost(double, tag = "14")]
    pub le: f64,
    /// comprises children of <detail>
    /// This is optional - if omitted, then the cot message
    /// had no data under <detail>
    #[prost(message, optional, tag = "15")]
    pub detail: ::core::option::Option<Detail>,
}
/// TAK Protocol control message
/// This specifies to a recipient what versions
/// of protocol elements this sender supports during
/// decoding.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakControl {
    /// Lowest TAK protocol version supported
    /// If not filled in (reads as 0), version 1 is assumed
    #[prost(uint32, tag = "1")]
    pub min_proto_version: u32,
    /// Highest TAK protocol version supported
    /// If not filled in (reads as 0), version 1 is assumed
    #[prost(uint32, tag = "2")]
    pub max_proto_version: u32,
    /// UID of the sending contact. May be omitted if
    /// this message is paired in a TakMessage with a CotEvent
    /// and the CotEvent contains this information
    #[prost(string, tag = "3")]
    pub contact_uid: ::prost::alloc::string::String,
}
/// Top level message sent for TAK Messaging Protocol Version 1.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TakMessage {
    /// Optional - if omitted, continue using last reported control
    /// information
    #[prost(message, optional, tag = "1")]
    pub tak_control: ::core::option::Option<TakControl>,
    /// Optional - if omitted, no event data in this message
    #[prost(message, optional, tag = "2")]
    pub cot_event: ::core::option::Option<CotEvent>,
}
